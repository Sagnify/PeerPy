<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebRTC Shared Whiteboard</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    canvas { border: 1px solid #ccc; background-color: #f9f9f9; cursor: crosshair; }
    input { padding: 5px; margin: 5px; }
    button { padding: 5px 10px; margin: 5px; }
    .status { color: #666; font-style: italic; }
    .error { color: red; }
    .success { color: green; }
    #colorPicker { width: 50px; height: 25px; border: none; padding: 0; vertical-align: middle; }
    #brushSize { width: 50px; vertical-align: middle; }
  </style>
</head>
<body>
  <h2>WebRTC Shared Whiteboard</h2>

  <label>Room: <input type="text" id="room" value="whiteboard_room"></label><br><br>
  <label>Peer ID: <input type="text" id="peerId" value="" placeholder="Enter unique peer ID"></label><br>
  <label><input type="checkbox" id="debugMode"> Enable Debug Logging</label><br><br>
  <button id="connectButton">Connect</button>
  <button id="disconnectButton">Disconnect</button>
  <button id="generateIdButton">Generate Random Peer ID</button>

  <div id="status" class="status">Disconnected</div>

  <div>
    Brush Color: <input type="color" id="colorPicker" value="#000000">
    Brush Size: <input type="range" id="brushSize" min="1" max="20" value="5">
    <button id="clearButton">Clear Whiteboard</button>
  </div>

  <canvas id="whiteboardCanvas" width="800" height="600"></canvas>

  <script type="module">
    import { WebRTCConnection } from '/peerpyrtc_client/myrtclib.js';

    let rtcConnection;
    const canvas = document.getElementById('whiteboardCanvas');
    const ctx = canvas.getContext('2d');

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    function log(message, type = "") {
      console.log(`[LOG] ${type}: ${message}`);
    }

    function updateStatus(status) {
      const statusEl = document.getElementById("status");
      statusEl.textContent = status;
    }

    function generatePeerID() {
      const randomID = 'wb-peer-' + Math.random().toString(36).substr(2, 9);
      document.getElementById("peerId").value = randomID;
      log(`Generated peer ID: ${randomID}`, "status");
    }

    function drawLine(x1, y1, x2, y2, color, size) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function showCursor(peerId, x, y, color) {
      // Remove existing cursor for this peer
      const existingCursor = document.getElementById(`cursor-${peerId}`);
      if (existingCursor) {
        existingCursor.remove();
      }

      // Create new cursor
      const cursor = document.createElement('div');
      cursor.id = `cursor-${peerId}`;
      cursor.style.cssText = `
        position: absolute;
        left: ${canvas.offsetLeft + x - 5}px;
        top: ${canvas.offsetTop + y - 5}px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: ${color};
        border: 2px solid white;
        pointer-events: none;
        z-index: 1000;
      `;
      document.body.appendChild(cursor);

      // Remove cursor after 2 seconds
      setTimeout(() => cursor.remove(), 2000);
    }

    // Canvas drawing event handlers
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    });

    canvas.addEventListener('mousemove', (e) => {
      const color = document.getElementById('colorPicker').value;
      const size = document.getElementById('brushSize').value;

      if (isDrawing) {
        // Draw locally
        drawLine(lastX, lastY, e.offsetX, e.offsetY, color, size);

        // Send drawing data over WebRTC using emit
        if (rtcConnection && rtcConnection.isConnected()) {
          rtcConnection.emit('draw', {
            x1: lastX,
            y1: lastY,
            x2: e.offsetX,
            y2: e.offsetY,
            color: color,
            size: size
          });
        }

        [lastX, lastY] = [e.offsetX, e.offsetY];
      } else {
        // Show cursor position to other users
        if (rtcConnection && rtcConnection.isConnected()) {
          rtcConnection.emit('cursor', {
            x: e.offsetX,
            y: e.offsetY,
            color: color
          });
        }
      }
    });

    canvas.addEventListener('mouseup', () => isDrawing = false);
    canvas.addEventListener('mouseout', () => isDrawing = false);

    document.getElementById('clearButton').addEventListener('click', () => {
      clearCanvas();
      if (rtcConnection && rtcConnection.isConnected()) {
        rtcConnection.emit('clear', {});
      }
    });

    async function connect() {
      const roomName = document.getElementById("room").value;
      const peerId = document.getElementById("peerId").value;
      const debugMode = document.getElementById("debugMode").checked;
      
      if (!roomName || !peerId) {
        log("Please enter both room name and peer ID", "error");
        return;
      }

      log("Connecting...", "status");
      updateStatus("Connecting...");

      rtcConnection = new WebRTCConnection(roomName, { peerId: peerId, debug: debugMode });

      rtcConnection.onMessage = (sender_id, message, event) => {
        if (event) {
          // Handle emit() events
          if (event === 'draw') {
            drawLine(message.x1, message.y1, message.x2, message.y2, message.color, message.size);
          } else if (event === 'clear') {
            clearCanvas();
          } else if (event === 'cursor') {
            showCursor(sender_id, message.x, message.y, message.color);
          }
        } else {
          // Handle regular messages (if any)
          console.log(`Message from ${sender_id}:`, message);
        }
      };

      rtcConnection.onOpen = () => {
        log("Connection established! You can now draw.", "success");
        updateStatus("Connected");
      };

      rtcConnection.onClose = () => {
        log("Connection closed.", "error");
        updateStatus("Disconnected");
      };

      rtcConnection.onError = (error) => {
        log(`WebRTC Error: ${error.message}`, "error");
        updateStatus("Connection failed");
      };

      rtcConnection.onStatusChange = (status) => {
        updateStatus(status);
      };

      try {
        await rtcConnection.connect();
        log(`Joined room: ${roomName} as ${peerId}`, "success");
      } catch (error) {
        console.error("[ERROR] Failed to connect:", error);
        log(`Failed to connect: ${error.message}`, "error");
        updateStatus("Connection failed");
      }
    }

    async function disconnect() {
      if (rtcConnection) {
        await rtcConnection.closeConnection();
        log("Disconnected.", "status");
        updateStatus("Disconnected");
      }
    }

    // Event Listeners
    window.addEventListener('load', () => {
      generatePeerID();
      document.getElementById("connectButton").onclick = connect;
      document.getElementById("disconnectButton").onclick = disconnect;
      document.getElementById("generateIdButton").onclick = generatePeerID;
    });

    window.addEventListener('beforeunload', () => {
      if (rtcConnection) {
        rtcConnection.closeConnection();
      }
    });
  </script>
</body>
</html>